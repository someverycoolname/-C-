\section{Концепция асинхронных операций, классы \mintinline{csharp}{Task}, \mintinline{csharp}{TaskFactory}, использование \mintinline{csharp}{async}/\mintinline{csharp}{await}}

\subsection{Введение}

Асинхронная концепция программирования заключается в том, что результат выполнения функции доступен не сразу же, а через некоторое время в виде некоторого асинхронного (нарушающего обычный порядок выполнения) вызова. Данная парадигма зачастую применяется в реальных приложениях, т.к. блокировка основного потока выполнения обычно является нежелательной. В данной главе мы рассмотрим применение класса Task для создания и выполнения асинхронных операций, а так же синтаксиса async/await, введенного в C# 5.0.

\subsubsection{Явное создание и запуск задач, класс Task}

Экземпляр класса Task описывает асинхронную операцию или же задачу, не возвращающую никакого значения. 
Задача, возвращающая значение представляется классом Task<TResult>, унаследованного от Task.

Объект задачи обрабатывает сведения инфраструктуры и предоставляет методы и свойства, доступные из вызывающего потока в течение времени существования задачи. Например, можно получить доступ к свойству Status задачи в любое время для определения того, было ли начато ее выполнение, завершилась ли она, была ли отменена или создала исключение. Состояние представлено перечислением TaskStatus.

При создании задачи ей передается пользовательский делегат, инкапсулирующий код, который будет выполнять задача. Делегат может быть выражен как именованный делегат, анонимный метод или лямбда-выражение. Лямбда-выражения могут содержать вызов именованного метода, как показано в следующем примере. Стоит обратить внимание, что в пример включен вызов метода Task.Wait, чтобы убедиться в окончании выполнения задачи до завершения работы приложения.

public static void Main()
{
  Thread.CurrentThread.Name = "Main";

  // Создадим задачу и задаим ей делегат.
  var taskA = new Task(() => Console.WriteLine("Выполнена задача taskA"));
  
  // Запустим задачу taskA
  taskA.Start();

  // Выведем сообщение из текущего потока
  Console.WriteLine("Сообщение из потока {0}", 
                    Thread.CurrentThread.Name);
  taskA.Wait();
}

Результат выполнения программы:
Сообщение из потока Main
Выполнена задача taskA

Для создания и запуска задачи в одной операции можно также использовать методы Task.Run. Для управления задачей методы Run используют планировщик задач по умолчанию независимо от того, какой планировщик связан с текущим потоком. Методы Run — предпочтительный способ создания и запуска задач, если не требуется более жесткий контроль над созданием и планированием задачи.

var taskA = Task.Run(() => Console.WriteLine("Выполнена задача taskA"));


Для создания и запуска задачи в одной операции можно также использовать метод TaskFactory.StartNew. Используйте этот метод, если нет необходимости разделять создание и планирование и требуются дополнительные параметры создания задач или использование определенного планировщика, а также при необходимости передачи дополнительного состояния задаче через ее свойство AsyncState, как показано в следующем примере:

var taskA = Task.Factory.StartNew(() => Console.WriteLine("Выполнена задача taskA"));

Классы Task и Task<TResult> предоставляют статическое свойство Factory, возвращающее экземпляр по умолчанию объекта TaskFactory, чтобы можно было вызвать метод как Task.Factory.StartNew(). Кроме того, поскольку в следующем примере задачи относятся к типу System.Threading.Tasks.Task<TResult>, каждая из них имеет открытое свойство Task<TResult>.Result, содержащее результат вычисления. Задачи выполняются асинхронно и могут завершиться в любом порядке. При обращении к свойству Result до завершения вычисления оно блокирует вызывающий поток до тех пор, пока значение не станет доступно.

public static void Main()
{
    var taskArray = { 
        Task<double>.Factory.StartNew(() => DoComputation(1.0)),
        Task<double>.Factory.StartNew(() => DoComputation(100.0)), 
        Task<double>.Factory.StartNew(() => DoComputation(1000.0)) 
    };

    var results = new double[taskArray.Length];
    var sum = 0.0d;
    
    for (int i = 0; i < taskArray.Length; i++) {
        results[i] = taskArray[i].Result;
        sum += results[i];
        
        Console.Write("{0:N1} {1}", results[i], 
            i == taskArray.Length - 1 ? "= " : "+ ");
    }
    Console.WriteLine("{0:N1}", sum);
}

private static double DoComputation(double start)
{
  var sum = 0.0d;
  for (var value = start; value <= start + 10; value += .1)
     sum += value;

  return sum; 
}

Результат выполнения:
606.0 + 10,605.0 + 100,495.0 = 111,706.0

\subsubsection{Ожидание завершения задач}

Типы System.Threading.Tasks.Task и System.Threading.Tasks.Task<TResult> предоставляют несколько перегрузок методов Task.Wait и System.Threading.Tasks.Task.Wait, которые позволяют ожидать завершения задачи. Кроме того, перегрузки статических методов Task.WaitAll и Task.WaitAny позволяют ожидать завершения какого-либо или всех массивов задач.

Как правило, ожидание задачи выполняется по одной из следующих причин.

Основной поток зависит от конечного результата, вычисленного задачей.

Необходимо обрабатывать исключения, которые могут быть созданы из задачи.

Приложение может завершиться до окончания выполнения всех задач. Например, выполнение консольных приложений завершается после выполнения всего синхронного кода в Main (точке входа приложения).

В следующем примере показан пример, в котором не указана обработка исключений:

Task[] tasks = new Task[3]
{
    Task.Factory.StartNew(() => MethodA()),
    Task.Factory.StartNew(() => MethodB()),
    Task.Factory.StartNew(() => MethodC())
};

// Блокировать текущий поток до выполнения всех задач.
Task.WaitAll(tasks);

// Исполнение кода продолжится после выполнения всех задач...

Стоит обратить внимание, что любые исключения, вызванные задачей, будут созданы методом Task.Wait, даже если метод Task.Wait был вызван после завершения задачи.


\subsection{Ситаксис async/await}

\subsubsection{Введение и пример использования}

Операторы async и await используются вместе для создания асинхронного метода. Такой метод, определенный с помощью модификатора async и содержащий одно или несколько выражений await, называется асинхронным методом.

Сразу стоит уточнить! Ключевое слово async не приводит к тому, что метод будет выполняться в фоновом потоке (как кажется из названия), а только отмечает, что внутри метода присутствует await, который работает с Task и Task<T> таким образом, что код метода после await будет выполнен после завершения Task, но в начальном потоке.

Введя новый синтаксис, Microsoft фактически предложила синтаксический сахар и расширение для Task с целью упрощения написания асинхронного кода.

Рассмотрим простейший пример:

public Task<Data> GetDataAsync()
{
    return MyWebService.FetchDataAsync()
        .ContinueWith(t => new Data (t.Result));
}

public async Task<Data> GetDataAsync()
{
    var result = await MyWebService.FetchDataAsync();
    return new Data(result);
}

В терминах производительности, оба метода, представленные выше, имеют небольшие накладные расходы, но они несколько по-разному масштабируются при увеличении количества задач в них:

Task строит цепочку продолжений, которая увеличивается в соответствии с количеством задач, связанных последовательно, и состояние системы управляется через замыкания, найденные компилятором.

async/await строит машину состояний, которая не использует дополнительных ресурсов при добавлении новых шагов. Однако компилятор может определить больше переменных для сохранение в стеки машины состояний, в зависимости от вашего кода (и компилятора).

В большинстве реальных сценариев async/await будет использовать меньше ресурсов и выполняться быстрее, чем задачи Task.


\subsubsection{Контекст в асинхронном коде}

Код .NET всегда исполняется в некотором контексте. Этот контекст определяет текущего пользователя и другие значения, требуемые фреймворком. В некоторых контекстах выполнения, код работает в контексте синхронизации, который управляет выполнением задач и другой асинхронной работы.

По-умолчанию, после await код продолжит работать в контексте, в котором он был запущен. Это удобно, потому что в основном вы захотите, чтобы контекст безопасности был восстановлен, и вы хотите, чтобы ваш код после await имел доступ к объектам потока UI, если он уже имел доступ к ним при старте. Заметим, что Task.Factory.StartNew – не осуществляет восстановление контекста.

Некоторые контексты синхронизации не поддерживают повторный вход в них и являются однопоточными. Это означает, что только одна единица работы может выполняться в этом контексте одновременно. Примером этого может быть поток Windows UI или контекст ASP.NET.

В таких однопоточных контекстах синхронизации довольно легко получить deadlock. Если вы создадите задачу в однопоточном контексте, и потом будете ждать в этом же контексте, ваш код, который ждёт, будет блокировать выполнение фоновой задачи.

public ActionResult ActionAsync()
{
    // DEADLOCK: это блокирует асинхронную задачу
    // которая ждёт, когда она сможет выполняться в этом контексте
    var data = GetDataAsync().Result;

    return View(data);
}

private async Task<string> GetDataAsync()
{
    // простой вызов асинхронного метода
    var result = await MyWebService.GetDataAsync();
    return result.ToString();
}

Как основное правило – если вы создаёте асинхронный код, будьте осторожны c использованием Wait. (c await всё несколько лучше.)

Не используйте Wait для задач в однопоточных контекстах синхронизации, таких как:
Потоки UI
Контекст ASP.NET

Хорошая новость заключается в том, что фреймворк позволяет вам возвращать Task в определённых случаях, и сам фреймворк будет ожидать выполнения задачи. Доверье ему этот процесс:

public async Task<ActionResult> ActionAsync()
{
    // этот метод использует async/await и возвращает Task
    var data = await GetDataAsync();

    return View(data);
}

Если вы создаёте асинхронные библиотеки, ваши пользователи должны будут писать асинхронный код. Раньше это было проблемой, так как написание асинхронного кода было утомительным и уязвимым для ошибок, но с появлением async/await большая часть сложности теперь обрабатывается компилятором. А ваш код получает большую надёжность, и вы теперь с меньше вероятностью будете вынуждены бороться с нюансами ThreadPool/Task/TaskFactory.

Если вы обязаны ожидать выполнения задачи в одном из этих контекстов, вы можете использовать ConfigureAwait, чтобы сказать системе, что она не должна выполнять фоновую задачу в вашем контексте. Недостатком этого является то, что фоновая задача не будет иметь доступа к тому же самому контексту синхронизации, так что вы потеряете доступ к потоку UI или HttpContext.

Обратите внимание! ConfigureAwait(false) надо использовать в любом коде, который не нуждается в доступе к потоку UI, но запускается из потока UI, иначе управление будет постоянно возвращаться к нему и часть работы будет выполняться в потоке UI.

Также, если вы создаёте «библиотечную» функцию, которая возвращает Task, вы, скорее всего, не знаете, как она будет вызываться. Так что, возможно, будет безопаснее добавить ConfigureAwait(false) к вашей задаче перед тем как её вернуть.

Пример использования:

private async Task<string> GetDataAsync()
{
    // ConfigureAwait(false) говорит системе, чтобы она
    // позволила оставшемуся коду выполняться в любом контексте
    var result = await MyWebService.GetDataAsync().ConfigureAwait(false);
    return result.ToString();
}

\subsubsection{Исключения при использовании async/await}

Когда смотришь на асинхронный код, тяжело иногда сказать, что же случается с исключениями. Будет ли оно передано вызывающей функции, или тому коду, который ждёт выполнения задачи?

Рассмотрим несколько примеров для понимания.

Исключения, вызванные из самого async/await метода, будут отправлены коду, ожидающему выполнения задачи (awaiter).

public async Task<Data> GetContentsOfUrl(string url)
{
    // это исключение будет вызвано на коде, ожидающем 
    // выполнения этой задачи
    if (url == null) throw new ArgumentNullException();

    var data = await MyWebService.GetContentsOfUrl();
    return data.DoStuffToIt();
}

Исключения, вызванные из делегата задачи Task, тоже будут отправлены коду, ожидающему выполнения задачи (awaiter).

public Task<Data> GetContentsOfUrl(string url)
{
    return Task<Data>.Factory.StartNew(() =>
    {
        // это исключение будет вызвано на коде, ожидающем 
        // выполнения этой задачи
        if (url == null) throw new ArgumentNullException();

        var data = await MyWebService.GetContentsOfUrl();
        return data.DoStuffToIt();
    }
}

Исключения, вызванные во время создания Task, будут отправлены коду, который вызывал этот метод (caller) (что, в общем, очевидно):

public Task<Data> GetContentsOfUrl(string url)
{
    // это исключение будет вызвано на вызывающем коде
    if (url == null) throw new ArgumentNullException();

    return Task<Data>.Factory.StartNew(() =>
    {
        var data = await MyWebService.GetContentsOfUrl();
        return data.DoStuffToIt();
    }
}

Последний пример является одной из причин, почему предпочтительно использование async/await вместо создания цепочек задач посредством Task.